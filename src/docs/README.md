# 1. net-http-clean-architecture-sample
Golangの**net/http**パッケージを使用したAPI開発
下記のようなディレクトリ構造になっている

```txt
repository -> database関連
route      -> ルーティング
controller -> コントローラーやハンドラー
config     -> configの設定（環境変数など）
service    -> サービス
log        -> ログ関連
```

Databaseには**GORM**

configには**gopkg.in/ini.v1**

logには**github.com/sirupsen/logrus**

## 1.1 アーキテクチャについて
今回、、レイヤードアーキテクチャーを採用しました。
レイヤードとは層という意味ですが、以下の層に分けて、アプリケーションを構築します。

```text
ユーザインターフェース(Controller)
ユースケース
ドメイン
インフラストラクチャー
```

**上ほど抽象度が高くなっており、上位レイヤーが下位レイヤーを利用します。**


利用の向きは以下の通りです。

```text
ユーザインターフェース
↓
ユースケース
↓
ドメイン
↓
インフラストラクチャー
```

ただ、依存関係は以下の通りとなります。

```text
ユーザインターフェース
↓
ユースケース
↓
ドメイン
↑
インフラストラクチャー
```

**ドメインやアプリケーションからインフラストラクチャーへの依存**はインターフェースを通して利用するため、インフラからドメインに依存しています。

そのことを**依存関係性の逆転**と言います。

---

## 1.2 用語の説明
### ユーザインターフェース(controller)
```text
第三者の利用者とサービスをつなげるインターフェース部分です。
クライアント側の入力を受け取り、ユーザ側に結果を返す役割を担います。
MVCモデルのコントローラーと思ってもらって大丈夫です

今回はcontrollerディレクトリがユーザーインターフェースに当たります
```

### ユースケース
```text
進行役を担います。
進行役のため、ドメインのルールやロジックは禁止です。
例えば、ユーザ名は50文字までいったことや、「|[{<>}]?!@#$%^&*()_」は禁止文字であることは記述禁止です。
ユースケースなので、たとえば、ユーザを登録登録の一連処理、商品を購入する一連処理を記述するイメージです。

今回はusecaseディレクトリがユースケースに当たります
```

### ドメイン
```text
ドメインに関することを書きます。
例えば、「ユーザ名」、「パスワード」、「商品」があり、それぞれ50文字であることや、利用禁止文字があるなどのルール（ロジック）があれば、記述します。

ドメイン駆動開発では、ここが一番大切。ここをみれば、どういった仕様なのか？知れるようにすることが大事になってきます。

コードそのものをドキュメントとする考えとなっており、別途ドキュメントを残す必要がないことを目指します。
別途ドキュメントを残すと、更新漏れがあったり、記述ミスがある可能性があったり、手間が増える。コードそのものをドキュメントとすることが一番確実になります。

今回はdomainディレクトリがドメインに当たります
```

### インフラストラクチャー
```text
ここでは、他の層を支える技術的な基盤を描きます。
データベースやキャッシュサーバーなどの処理などです。
DBに依存する記述やSQLなどはこの層に書きます。

抽象度が高い存在（ユーザを新規登録する、など）にとって、何に保存するか（MySQL、Postgressなど）は関係なくどうでも良いです。何かの媒体を使って保存してくれることのみが大事。なので、その情報を切り分けることで、変更に強くなります。

今回はrepositoryディレクトリがドメインに当たります
```
---

## 1.3 ディレクトリでの説明
### コントローラー(/controller)
```text
レイヤードアーキテクチャーでいうと、ユーザインターフェースの部分になります。

具体的には、以下のことを行います。

クライアントからきたデータのバリデーションを行う
クライアントにステータスなどを含めたデータ返す
ユースケースの依頼はインターフェースを利用してサービス層(domain)に依頼します。
```

### ユースケース(/usecase)
```text
レイヤードアーキテクチャーでいうと、アプリケーションの部分になります。

具体的には、以下のことを行います。

ドメインとリポジトリを利用してユースケース（機能）の実装を行う
リポジトリは、インターフェースを通して利用する
ビジネスロジックは記述しない
```

### ドメイン(/domain)
```text
レイヤードアーキテクチャーでいうと、ドメインの部分になります。

具体的には以下のことを行います。

ユーザや、パスワードなどサービス間をまたがるドメインは関するロジックなど記述をする
リポジトリは、インターフェースを通して利用する
リポジトリのインターフェースを格納
ドメイン駆動開発では、値オブジェクト、エンティティ、ドメインサービスがあります。
今回、　値オブジェクト、エンティティはdomain/model、ドメインサービスはdomain/serviceに格納するとしました。

サービスドメインを少し解説します。
値オブジェクトやエンティティに記述するとドメイン的に不自然になる場合はドメインサービスに記述します。
不自然な振る舞いの例として以下があります。
-------------------
ユーザの重複を確認することを考える
ユーザの重複をエンティティに記述すると、ユーザー自身に自身の重複を確認するという現実世界ではおかしな振る舞いになる
その場合、ユーザサービスドメインに記述する
-------------------
ドメインサービスは、できる限りは使わない方が良いとされるので、どうしても不自然である場合のみ利用するように心がけましょう。

また、各ドメインは凝縮度を意識してを作成することが大事になります。
```
### リポジトリ(/repository)
```text
レイヤードアーキテクチャーでいうと、インフラストラクチャーの部分になります。
具体的には以下のことをやります。

ドメイン層で定義したインターフェースを実装する
SQLをかいて、DBにアクセスする
キャッシュサーバーへのアクセス
```
---
### 全体ツリー
```text
├── config # 環境変数の読み込み
│   └── config.go
├── config.ini
├── config.ini.sample
├── constant # アプリケーション全体で利用する定数
│   └── constant.go
├── controller # コントローラー(ユーザーインターフェース)
│   ├── README.md
│   ├── auth_handle
│   │   └── signup.go
│   ├── hello_world_handler.go
│   ├── service.go  # サービスのインターフェース
│   └── responce.go # レスポンス用フォーマットの定義
├── docs # ドキュメント
│   └── README.md
├── domain # ドメイン
│   ├── README.md
│   ├── interface.go # リポジトリのインテーフェース
│   ├── model # 値オブジェクト、エンティティ
│   │   └── user
│   │       ├── email_value_object.go
│   │       ├── password_value_object.go
│   │       └── user.go
│   └── service # ドメインサービス
│       └── user_service.go
├── go.mod
├── go.sum
├── log
│   └── 2023-6-29.log
├── main.go
├── repository # リポジトリ
│   ├── README.md
│   ├── administer.go
│   ├── db.go # DBへの接続のための記述
│   ├── error.go # DBによるエラーの定義
│   └── transaction.go # トランザクションを行うための記述
├── route # ルーティング
│   ├── README.md
│   ├── auth_router.go # 認証が必要なエンドポイント
│   └── router.go # 認証が不必要なエンドポイント
├── usecase # ユースケース
│   └── auth_usecase
│       └── signup.go
└── utils # ユーティリティ
    ├── contains.go
    ├── my_error.go
    └── write_log_file.go

```
